---
title: "Create Data Transfer Objects (DTOs) | Microsoft Docs"
author: MikeWasson
description: ""
ms.author: riande
manager: wpickett
ms.date: 06/16/2014
ms.topic: article
ms.assetid: 
ms.technology: dotnet-webapi
ms.prod: .net-framework
msc.legacyurl: /web-api/overview/data/using-web-api-with-entity-framework/part-5
---
[Edit .md file](C:\Projects\msc\dev\Msc.Www\Web.ASP\App_Data\github\web-api\overview\data\using-web-api-with-entity-framework\part-5.md) | [Edit dev content](http://www.aspdev.net/umbraco#/content/content/edit/58255) | [View dev content](http://docs.aspdev.net/tutorials/web-api/overview/data/using-web-api-with-entity-framework/part-5.html) | [View prod content](http://www.asp.net/web-api/overview/data/using-web-api-with-entity-framework/part-5) | Picker: 58296

Create Data Transfer Objects (DTOs)
====================
by [Mike Wasson](https://github.com/MikeWasson)

[Download Completed Project](https://github.com/MikeWasson/BookService)

Right now, our web API exposes the database entities to the client. The client receives data that maps directly to your database tables. However, that's not always a good idea. Sometimes you want to change the shape of the data that you send to client. For example, you might want to:

- Remove circular references (see previous section).
- Hide particular properties that clients are not supposed to view.
- Omit some properties in order to reduce payload size.
- Flatten object graphs that contain nested objects, to make them more convenient for clients.
- Avoid "over-posting" vulnerabilities. (See [Model Validation](../../formats-and-model-binding/model-validation-in-aspnet-web-api.md) for a discussion of over-posting.)
- Decouple your service layer from your database layer.

To accomplish this, you can define a *data transfer object* (DTO). A DTO is an object that defines how the data will be sent over the network. Let's see how that works with the Book entity. In the Models folder, add two DTO classes:

    namespace BookService.Models
    {
        public class BookDTO
        {
            public int Id { get; set; }
            public string Title { get; set; }
            public string AuthorName { get; set; }
        }
    }
    
    namespace BookService.Models
    {
        public class BookDetailDTO
        {
            public int Id { get; set; }
            public string Title { get; set; }
            public int Year { get; set; }
            public decimal Price { get; set; }
            public string AuthorName { get; set; }
            public string Genre { get; set; }
        }
    }

The `BookDetailDTO` class includes all of the properties from the Book model, except that `AuthorName` is a string that will hold the author name. The `BookDTO` class contains a subset of properties from `BookDetailDTO`.

Next, replace the two GET methods in the `BooksController` class, with versions that return DTOs. We'll use the LINQ **Select** statement to convert from Book entities into DTOs.

    // GET api/Books
    public IQueryable<BookDTO> GetBooks()
    {
        var books = from b in db.Books
                    select new BookDTO()
                    {
                        Id = b.Id,
                        Title = b.Title,
                        AuthorName = b.Author.Name
                    };
    
        return books;
    }
    
    // GET api/Books/5
    [ResponseType(typeof(BookDetailDTO))]
    public async Task<IHttpActionResult> GetBook(int id)
    {
        var book = await db.Books.Include(b => b.Author).Select(b =>
            new BookDetailDTO()
            {
                Id = b.Id,
                Title = b.Title,
                Year = b.Year,
                Price = b.Price,
                AuthorName = b.Author.Name,
                Genre = b.Genre
            }).SingleOrDefaultAsync(b => b.Id == id);
        if (book == null)
        {
            return NotFound();
        }
    
        return Ok(book);
    }

Here is the SQL generated by the new `GetBooks` method. You can see that EF translates the LINQ **Select** into a SQL SELECT statement.

    SELECT 
        [Extent1].[Id] AS [Id], 
        [Extent1].[Title] AS [Title], 
        [Extent2].[Name] AS [Name]
        FROM  [dbo].[Books] AS [Extent1]
        INNER JOIN [dbo].[Authors] AS [Extent2] ON [Extent1].[AuthorId] = [Extent2].[Id]

Finally, modify the `PostBook` method to return a DTO.

    [ResponseType(typeof(Book))]
    public async Task<IHttpActionResult> PostBook(Book book)
    {
        if (!ModelState.IsValid)
        {
            return BadRequest(ModelState);
        }
    
        db.Books.Add(book);
        await db.SaveChangesAsync();
    
        // New code:
        // Load author name
        db.Entry(book).Reference(x => x.Author).Load();
    
        var dto = new BookDTO()
        {
            Id = book.Id,
            Title = book.Title,
            AuthorName = book.Author.Name
        };
    
        return CreatedAtRoute("DefaultApi", new { id = book.Id }, dto);
    }

> [!NOTE] In this tutorial, we're converting to DTOs manually in code. Another option is to use a library like [AutoMapper](http://automapper.org/) that handles the conversion automatically.

>[!div class="step-by-step"] [Previous](part-4.md) [Next](part-6.md)